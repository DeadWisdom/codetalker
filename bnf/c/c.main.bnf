
# modifications to the stock basic-expression.bnf

literal:add
    character-literal

start:
    external-declaration*

external-declaration:
    pp-line
    function
    declaration

## function stuff

function:
    declaration-specifier*? declarator function-tail

function-tail:
    ';'
    declaration* compound-st

## basic declaration + initalization

declaration:
    declaration-specifier+? init-declarator-list ';'

init-declarator-list:
    init-declarator init-tail*

init-declarator:
    declarator init-declarator-tail?

init-declarator-tail:
    '=' initializer

init-tail:
    ',' init-declarator

## basic expression

expression:replace
    assignment-ex expression-tail*

expression-tail:
    ',' assignment-ex

## const, auto, int, etc declarator prefixes

declaration-specifier:
    storage-class-specifier
    type-specifier
    type-qualifier

type-qualifier: one of
    const
    volatile

storage-class-specifier: one of
    typedef
    extern
    static
    auto
    register

type-specifier:
    type-keyword
    enum-specifier
    struct-specifier
    identifier

type-keyword: one of
    struct
    void
    char
    short
    int
    long
    float
    double
    signed
    unsigned

## declarator -- the base of regular variable initalizaton and functions

declarator:
    pointer* direct-declarator

pointer:
    '*' type-qualifier*

direct-declarator:
    direct-base direct-post*

direct-base:
    identifier
    '(' declarator ')'

direct-post:
    '[' cond-ex? ']'
    '(' direct-contents? ')'

direct-contents:
    parameter-list
    identifier-list

identifier-list:
    identifier identifier-tail*

identifier-tail:
    ',' identifier

parameter-list:
    parameter-declaration parameter-tail*

parameter-tail:
    ',' parameter-declaration

parameter-declaration:
    declaration-specifier* abstract-declarator?

abstract-declarator:
    declarator
    pointer? direct-abstract-declarator
    pointer

direct-abstract-declarator:
    direct-abs-base? direct-abs-tail*

direct-abs-base:
    '(' abstract-declarator ')'

direct-abs-tail:
    '(' parameter-list? ')'
    '[' cond-ex? ']'

## initializers

initializer:
    '{' initializer-list ','? '}'
    assignment-ex

initializer-list:
    initializer initializer-tail*

initializer-tail:
    ',' initializer

## statements

statement:
    labeled-st
    compound-st
    expression-st
    selection-st
    iteration-st
    jump-st

labeled-st:
    'case' cond-ex ':' statement
    'default' ':' statement
    identifier ':' statement

compound-st:
    '{' declaration* statement* '}'

expression-st:
    expression? ';'

selection-st:
    if-statement
    switch-statement

paren-expression:
    '(' expression ')'

if-statement:
    'if' paren-expression statement if-tail?

if-tail:
    'else' statement

switch-statement:
    'switch' paren-expression statement

iteration-st:
    while-statement
    do-statement
    for-statement

while-statement:
    'while' paren-expression statement

do-statement:
    'do' statement 'while' paren-expression ';'

for-statement:
    'for' '(' expression-st expression-st expression? ')' statement

jump-st:
    'goto' identifier ';'
    'continue' ';'
    'break' ';'
    'return' expression? ';'

## other -- struct, enum

struct-specifier:
    struct struct-tail

struct: one of
    struct union

struct-tail:
    identifier '{' struct-declaration* '}'
    '{' struct-declaration* '}'

struct-declaration:
    specifier-qualifier+ struct-declarator-list ';'

struct-declarator-list:
    struct-declarator struct-list-tail*

struct-list-tail:
    ',' struct-declarator

struct-declarator:
    declarator? ':' cond-ex
    declarator

specifier-qualifier:
    type-specifier
    type-qualifier

## enum

enum-specifier:
    'enum' identifier? '{' enum-list '}'
    'enum' identifier

enum-list:
    enumerator enum-tail*

enum-tail:
    ',' enumerator

enumerator:
    identifier enumerator-tail?

enumerator-tail:
    '=' cond-ex
    


