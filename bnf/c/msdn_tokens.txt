### C.1 Lexical Grammar
# what does this mean??

input:
    input-section-part*

input-section:
    input-section-part+

input-section-part:
    input-element*   new-line
    pp-directive

input-elements:
    input-element+

input-element:
    whitespace
    comment
    token

### C.1.1 Line Terminators
#doesn't really deserve it's own section...

new-line:
    auto-rule-5

### C.1.2 White space
# needs to be updated to fit all; Any Ucode Zs

whitespace:
    ' '
    '\n'
    '\t'

#    Any character with Unicode class Zs
#    Horizontal tab character (U+0009)
#    Vertical tab character (U+000B)
#    Form feed character (U+000C)
### C.1.3 Comments

comment:
    single-line-comment
    delimited-comment

single-line-comment:
    '//'   input-character*

#input-characters:
#input-character
#input-characters   input-character

input-character:
    ^'\n'

#FIXME this could be broken :) doesnt check all newlines
#    Any Unicode character except a new-line-character

new-line-character:
    auto-rule-5

delimited-comment:
    '/*'   delimited-comment-character*   '*/'

#delimited-comment-characters:
#delimited-comment-character
#delimited-comment-characters   delimited-comment-character

delimited-comment-character:
    ^'*'
    ^'/'

#    not-asterisk
#    *   not-slash

#not-asterisk:
#Any Unicode character except *
#not-slash:
#Any Unicode character except /
### C.1.5 Unicode character escape sequences

unicode-escape-sequence:
    '\u'   hex-digit   hex-digit   hex-digit   hex-digit
    '\U'   hex-digit   hex-digit   hex-digit hex-digit   hex-digit   hex-digit   hex-digit   hex-digit



### C.1.4 Tokens
# these will be moved.

token:
    identifier
    keyword
    comment
    boolean-literal
    integer-literal
    real-literal
    character-literal
    string-literal
    null-literal
    operator-or-punctuator

### C.1.6 Identifiers

identifier:
    available-identifier
    '@'   identifier-or-keyword

available-identifier:
    identifier-or-keyword

# might need some looking at ^ needs to not be a keyword...

identifier-or-keyword:
    identifier-start-character   identifier-part-character*

identifier-start-character:
    letter-character
    _ 
#   (the underscore character U+005F)

#identifier-part-characters:
#identifier-part-character
#identifier-part-characters   identifier-part-character

identifier-part-character:
    letter-character
    decimal-digit-character
    connecting-character
    combining-character
    formatting-character

letter-character:
    %'[:Lu:Ll:Lt:Lm:Lo:Nl]'

#    A Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nl 
#    A unicode-escape-sequence representing a character of classes Lu, Ll, Lt, Lm, Lo, or Nl

combining-character:
    %'[:Mn:Mc]'
#    A Unicode character of classes Mn or Mc 
#    A unicode-escape-sequence representing a character of classes Mn or Mc

decimal-digit-character:
    %'[:Nd]'
#    A Unicode character of the class Nd 
#    A unicode-escape-sequence representing a character of the class Nd

connecting-character:
    %'[:Pc]'
#    A Unicode character of the class Pc 
#    A unicode-escape-sequence representing a character of the class Pc

formatting-character:
    %'[:Cf]'
#    A Unicode character of the class Cf 
#    A unicode-escape-sequence representing a character of the class Cf

### C.1.7 Keywords

keyword: one of
    abstract
    as
    base
    bool
    break
    byte
    case
    catch
    char
    checked
    class
    const
    continue
    decimal
    default
    delegate
    do
    double
    else
    enum
    event
    explicit
    extern
    false
    finally
    fixed
    float
    for
    foreach
    goto
    if
    implicit
    in
    int
    interface
    internal
    is
    lock
    long
    namespace
    new
    null
    object
    operator
    out
    override
    params
    private
    protected
    public
    readonly
    ref
    return
    sbyte
    sealed
    short
    sizeof
    stackalloc
    static
    string
    struct
    switch
    this
    throw
    true
    try
    typeof
    uint
    ulong
    unchecked
    unsafe
    ushort
    using
    virtual
    void
    volatile
    while

### C.1.8 Literals

boolean-literal:
    'true'
    'false'

integer-literal:
    decimal-integer-literal
    hexadecimal-integer-literal

decimal-integer-literal:
    decimal-digit+   integer-type-suffix?

#decimal-digits:
#    decimal-digit
#    decimal-digits   decimal-digit

decimal-digit: one of
    0 1 2 3 4 5 6 7 8 9

integer-type-suffix: one of
    U u L l UL Ul uL ul LU Lu lU lu

hexadecimal-integer-literal:
    '0x'   hex-digit+   integer-type-suffix?
    '0X'   hex-digit+   integer-type-suffix?

#hex-digits:
#    hex-digit
#    hex-digits   hex-digit

hex-digit: one of
    0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f

real-literal:
    decimal-digit+   '.'   decimal-digit+   exponent-part?   real-type-suffix?
    '.'   decimal-digit+   exponent-part?   real-type-suffix?
    decimal-digit+   exponent-part?   real-type-suffix?

#    decimal-digit+   real-type-suffix

exponent-part:
    e   sign?   decimal-digits
    E   sign?   decimal-digits

sign: one of
    + -

real-type-suffix: one of
    F f D d M m

character-literal:
    ''   character   ''

character:
    single-character
    simple-escape-sequence
    hexadecimal-escape-sequence
    unicode-escape-sequence

single-character: one of
    q w e r t y u i o p a s d f g h j k l z x c v b n m 
# FIXME
#    Any character except ' (U+0027), \ (U+005C), and new-line-character

simple-escape-sequence: one of
    \' \" \\ \0 \a \b \f \n \r \t \v

hexadecimal-escape-sequence:
    '\x'   hex-digit   hex-digit?   hex-digit?   hex-digit?

string-literal:
    regular-string-literal
    verbatim-string-literal

regular-string-literal:
    '"'   regular-string-literal-character*   '"'

#regular-string-literal-characters:
#    regular-string-literal-character
#    regular-string-literal-characters   regular-string-literal-character

regular-string-literal-character:
    single-regular-string-literal-character
    simple-escape-sequence
    hexadecimal-escape-sequence
    unicode-escape-sequence

single-regular-string-literal-character:
    dcontents
#    Any character except " (U+0022), \ (U+005C), and new-line-character

dcontents: one of 
    q w e r t y u i o p a s d f g h j k l z x c v b n m 

#FIXME ^ again char stuff

verbatim-string-literal:
    '@"'   verbatim -string-literal-character*   '"'

#verbatim-string-literal-characters:
#    verbatim-string-literal-character
#    verbatim-string-literal-characters   verbatim-string-literal-character

verbatim-string-literal-character:
    single-verbatim-string-literal-character
    quote-escape-sequence

single-verbatim-string-literal-character:
    ^'"'
#    any character except "

quote-escape-sequence:
    '""'

null-literal:
    'null'

### C.1.9 Operators and punctuators

operator-or-punctuator: one of
    { } [ ] ( ) . , : ; + - * / % & | ^ ! ~ = < > ? ++ -- && || << >> == != <= >= += -= *= /= %= &= |= ^= <<= >>= ->

### C.1.10 Pre-processing directives

pp-directive:
    pp-declaration
    pp-conditional
    pp-line
    pp-diagnostic
    pp-region

pp-new-line:
    whitespace?   single-line-comment?   new-line

conditional-symbol:
    identifier
#    Any identifier-or-keyword except true or false

pp-expression:
    whitespace?   pp-or-expression   whitespace?

pp-or-expression:
    pp-and-expression
    pp-or-expression   whitespace?   '||'   whitespace?   pp-and-expression

pp-and-expression:
    pp-equality-expression
    pp-and-expression   whitespace?   '&&'   whitespace?   pp-equality-expression

pp-equality-expression:
    pp-unary-expression
    pp-equality-expression   whitespace?   '=='   whitespace?   pp-unary-expression
    pp-equality-expression   whitespace?   '!='   whitespace?   pp-unary-expression

pp-unary-expression:
    pp-primary-expression
    '!'   whitespace?   pp-unary-expression

pp-primary-expression:
    'true'
    'false'
    conditional-symbol
    '('   whitespace?   pp-expression   whitespace?   ')'

pp-declaration:
    whitespace?   '#'   whitespace?   define   whitespace   conditional-symbol   pp-new-line
    whitespace?   '#'   whitespace?   undef   whitespace   conditional-symbol   pp-new-line

pp-conditional:
    pp-if-section   pp-elif-section*   pp-else-section?   pp-endif

pp-if-section:
    whitespace?   '#'   whitespace?   'if'   whitespace   pp-expression   pp-new-line   conditional-section?

pp-elif-sections:
    pp-elif-section
    pp-elif-sections   pp-elif-section

pp-elif-section:
    whitespace?   '#'   whitespace?   'elif'   whitespace   pp-expression   pp-new-line   conditional-section?

pp-else-section:
    whitespace?   '#'   whitespace?   'else'   pp-new-line   conditional-section?

pp-endif:
    whitespace?   '#'   whitespace?   'endif'   pp-new-line

conditional-section:
    input-section
    skipped-section

skipped-section:
    skipped-section-part
    skipped-section   skipped-section-part

skipped-section-part:
    skipped-characters?   new-line
    pp-directive

skipped-characters:
    whitespace?   not-number-sign   input-character*

not-number-sign:
    ^'#'
#    Any input-character except #

pp-line:
    whitespace?   '#'   whitespace?   line   whitespace   line-indicator   pp-new-line

line-indicator:
    decimal-digit+   whitespace   file-name
    decimal-digit+
    'default'

file-name:
    string-literal

#file-name-characters:
#    file-name-character
#    file-name-characters   file-name-character

#    Any input-character except "

pp-diagnostic:
    whitespace?   '#'   whitespace?   error   pp-message
    whitespace?   '#'   whitespace?   warning   pp-message

pp-message:
    new-line
    whitespace   input-character*   new-line

pp-region:
    pp-start-region   conditional-section?   pp-end-region

pp-start-region:
    whitespace?   '# '  whitespace?   'region'   pp-message

pp-end-region:
    whitespace?   '#'   whitespace?   'endregion'   pp-message

auto-rule-5:
    %'\r\n'
#    Carriage return character (U+000D)
#    Line feed character (U+000A)
#    Line separator character (U+2028)
#    Paragraph separator character (U+2029)

# used by new-line:, new-line-character:
